Introduction to Exponential-family Random Graph (ERG or p*) modeling with ergm
Version 3.8.0
The Statnet Development Team
August 20, 2017

Contents

1 Getting Started

1

2 Statistical network modeling; the ergm command and ergm object

2

3 Model terms available for ergm estimation and simulation

8

3.1 Terms provided with ergm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

3.2 Coding new terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

4 Network simulation: the simulate command and network.list objects

9

5 Examining the quality of model ﬁt – GOF

10

6 Diagnostics: troubleshooting and checking for model degeneracy

12

7 Working with egocentrically sampled network data

16

8 Additional functionality in the statnet family of packages

26

8.1 In the ergm and network packages: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

8.2 In other packages from the statnet suite: . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

8.2.1 Static (cross-sectional) network analysis packages . . . . . . . . . . . . . . . . . . 26

8.2.2 Dynamic (longitudinal) network analysis packages: . . . . . . . . . . . . . . . . . 26

8.3 R packages that build on statnet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

8.4 Additional functionality in development: . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

9 Statnet Commons: The core development team

27

1 Getting Started
This vignette is based on the ergm tutorial presented at INSNA Sunbelt - St. Pete Beach, Florida, Feb 2011.
Open an R session, and set your working directory to the location where you would like to save this work. You can do this with the pull-down menus (File>Change Dir) or with the command:

1

> setwd('full.path.for.the.folder')
To install all of the packages in the statnet suite:
> install.packages('statnet') > library(statnet)
Or, to only install the speciﬁc statnet packages needed for this tutorial:
> install.packages('network') > install.packages('ergm') > install.packages('sna') > library(network) > library(ergm) > library(sna)
After the ﬁrst time, to update the packages one can either repeat the commands above, or use:
> update.packages('name.of.package')
For this tutorial, we will need one additional package (coda), which is recommended (but not required) by ergm:
> install.packages('coda') > library(coda)
2 Statistical network modeling; the ergm command and ergm object
Make sure the statnet package is attached:
> library(statnet)
or
> library(ergm) > library(sna) > set.seed(1)
The ergm package contains several network data sets that you can use for practice examples.
> data(package='ergm') # tells us the datasets in our packages > data(florentine) # loads flomarriage and flobusiness data > flomarriage # Let's look at the flomarriage data
Network attributes: vertices = 16 directed = FALSE hyper = FALSE loops = FALSE
2

multiple = FALSE bipartite = FALSE total edges= 20
missing edges= 0 non-missing edges= 20 Vertex attribute names: priorates totalties vertex.names wealth No edge attributes > plot(flomarriage) # Let's view the flomarriage network
Remember the general ergm representation of the probability of the observed network, and the conditional log-odds of a tie:
Pr(Y = y) = exp[θ g(y)]/k(θ) Y is a network; g(y) is a vector of network stats; θ is the vector of coeﬃcients; k(θ) is a normalizing constant.
logit (Pr(Yij = 1|Y c)) = θ ∆ (g(y))ij Yij is an actor pair in Y ; Y c is the rest of the network; ∆ (g(y))ij is the change in g(y) when the value of Yij is toggled on. We begin with the simplest possible model, the Bernoulli or Erd?s-R?nyi model, which contains only an edge term.
3

> flomodel.01 <- ergm(flomarriage~edges) # fit model > flomodel.01
MLE Coefficients: edges
-1.609
> summary(flomodel.01) # look in more depth
========================== Summary of model fit ==========================

Formula: flomarriage ~ edges

Iterations: 5 out of 20

Monte Carlo MLE Results:

Estimate Std. Error MCMC % p-value

edges -1.6094 0.2449

0 <1e-04 ***

---

Signif. codes: 0 ^a˘A¨Y***^a˘A´Z 0.001 ^a˘A¨Y**^a˘A´Z 0.01 ^a˘A¨Y*^a˘A´Z 0.05 ^a˘A¨Y.^a˘A´Z 0.1 ^a˘A¨Y ^a˘A´Z 1

Null Deviance: 166.4 on 120 degrees of freedom Residual Deviance: 108.1 on 119 degrees of freedom

AIC: 110.1 BIC: 112.9 (Smaller is better.)

How to interpret this model? The log-odds of any tie occurring is:
−1.609 × change in the number of ties = −1.609 × 1
for all ties, since the addition of any tie to the network changes the number of ties by 1! Corresponding probability is:
exp(−1.609)/(1 + exp(−1.609)) = 0.1667
which is what you would expect, since there are 20/120 ties. Let’s add a term often thought to be a measure of “clustering”: the number of completed triangles.
Note we’re in stochastic simulation now – your output will diﬀer

> flomodel.02 <- ergm(flomarriage~edges+triangle) > summary(flomodel.02)
========================== Summary of model fit ==========================

Formula: flomarriage ~ edges + triangle

Iterations: 2 out of 20

4

Monte Carlo MLE Results:

Estimate Std. Error MCMC % p-value

edges

-1.6709

0.3551

0 <1e-04 ***

triangle 0.1523

0.5924

0 0.798

---

Signif. codes: 0 ^a˘A¨Y***^a˘A´Z 0.001 ^a˘A¨Y**^a˘A´Z 0.01 ^a˘A¨Y*^a˘A´Z 0.05 ^a˘A¨Y.^a˘A´Z 0.1 ^a˘A¨Y ^a˘A´Z 1

Null Deviance: 166.4 on 120 degrees of freedom Residual Deviance: 108.1 on 118 degrees of freedom

AIC: 112.1 BIC: 117.6 (Smaller is better.)

> coef1 = flomodel.02$coef[1] > coef2 = flomodel.02$coef[2] > logodds = coef1 + c(0,1,2) * coef2 > expit = function(x) 1/(1+exp(-x)) > ps = expit(logodds) > coef1 = round(coef1, 3) > coef2 = round(coef2, 3) > logodds = round(logodds, 3) > ps = round(ps, 3)

Again, how to interpret coeﬃcients? Conditional log-odds of two actors forming a tie is:
−1.671 × change in the number of ties + 0.152 × change in number of triangles

• if the tie will not add any triangles to the network, its log-odds is: −1.671. • if it will add one triangle to the network, its log-odds is: −1.671 + 0.152 = −1.519 • if it will add two triangles to the network, its log-odds is: −1.671 + 0.152 × 2 = −1.366 • the corresponding probabilities are 0.158, 0.18, and 0.203.

Let’s take a closer look at the ergm object itself:

> class(flomodel.02) # this has the class ergm

[1] "ergm"

> names(flomodel.02) # let's look straight at the ERGM obj.

[1] "coef" [5] "MCMCtheta" [9] "covar" [13] "newnetwork" [17] "stats.hist" [21] "formula" [25] "constraints" [29] "drop"

"sample"

"sample.obs"

"loglikelihood" "gradient"

"failure"

"network"

"coef.init" "est.cov"

"steplen.hist" "control"

"target.stats" "target.esteq"

"reference" "estimate"

"estimable" "null.lik"

"iterations" "hessian" "newnetworks" "coef.hist" "etamap" "constrained" "offset" "mle.lik"

> flomodel.02$coef 5

edges triangle -1.6709024 0.1522743

> flomodel.02$formula

flomarriage ~ edges + triangle

> flomodel.02$mle.lik
'log Lik.' -54.03178 (df=2) > wealth <- flomarriage %v% 'wealth' # the %v% extracts vertex > wealth # attributes from a network

[1] 10 36 55 44 20 32 8 42 103 48 49 3 27 10 146 48

> plot(flomarriage, vertex.cex=wealth/25) # network plot with vertex size

>

# proportional to wealth

We can test whether edge probabilities are a function of wealth:
> flomodel.03 <- ergm(flomarriage~edges+nodecov('wealth')) > summary(flomodel.03) ========================== Summary of model fit ==========================
Formula: flomarriage ~ edges + nodecov("wealth")
6

Iterations: 4 out of 20

Monte Carlo MLE Results:

Estimate Std. Error MCMC % p-value

edges

-2.594929 0.536056

0 <1e-04 ***

nodecov.wealth 0.010546 0.004674

0 0.0259 *

---

Signif. codes: 0 ^a˘A¨Y***^a˘A´Z 0.001 ^a˘A¨Y**^a˘A´Z 0.01 ^a˘A¨Y*^a˘A´Z 0.05 ^a˘A¨Y.^a˘A´Z 0.1 ^a˘A¨Y ^a˘A´Z 1

Null Deviance: 166.4 on 120 degrees of freedom Residual Deviance: 103.1 on 118 degrees of freedom

AIC: 107.1 BIC: 112.7 (Smaller is better.)

Yes, there is a signiﬁcant positive wealth eﬀect on the probability of a tie.

Let’s try a model or two on: Is there a statistically signiﬁcant tendency for ties to be reciprocated (’mutuality’)?
> data(samplk) > ls() # directed data: Sampson's Monks > samplk3 > plot(samplk3) > sampmodel.01 <- ergm(samplk3~edges+mutual) > summary(sampmodel.01)
Let’s try a larger network
> data(faux.mesa.high) > mesa <- faux.mesa.high

> plot(mesa)
> mesa > plot(mesa, vertex.col='Grade') > legend('bottomleft',fill=7:12,legend=paste('Grade',7:12),cex=0.75) > fauxmodel.01 <- ergm(mesa ~edges + nodematch('Grade',diff=T) + nodematch('Race',diff=T))
> summary(fauxmodel.01)

Note that two of the coeﬃcients are estimated as -Inf (the nodematch coeﬃcients for race Black and Other). Why is this?

> table(mesa %v% 'Race') # Frequencies of race

Black Hisp NatAm Other White

6 109 68

4 18

> mixingmatrix(mesa, "Race")

7

Note: Marginal totals can be misleading

for undirected mixing matrices.

Black Hisp NatAm Other White

Black 0 8 13 0 5

Hisp

8 53 41 1 22

NatAm 13 41 46 0 10

Other 0 1 0 0 0

White 5 22 10 0 4

So the problem is that there are very few students in the Black and Other race categories, and these students form no homophilous (within-group) ties. The empty cells are what produce the -Inf estimates.
Time to consider some missing data:

> missnet <- network.initialize(10,directed=F) > missnet[1,2] <- missnet[2,7] <- missnet[3,6] <- 1 > missnet[4,6] <- missnet[4,9] <- NA > missnet > plot(missnet) > ergm(missnet~edges)

The coeﬃcient equals -2.590. This is the log-odds of the probability .0698. Our network has 3 ties, out of the 43 nodal pairs (10 choose 2 minus 2) whose dyad status we have observed. 3/43 = 0.0698.

> ergm(missnet~edges+degree(2)) > missnet[4,6] <- missnet[4,9] <- 0 > ergm(missnet~edges+degree(2))

The two estimates for the degree 2 coeﬃcient diﬀer considerably. In the ﬁrst case, there is one node we know for sure has degree 2, two that may or may not, and seven that we know for sure do not. In the latter, there is one node that has degree 2, and nine that do not.

3 Model terms available for ergm estimation and simulation
Model terms are the expressions (e.g. “triangle”) used to represent predictors on the right-hand size of equations used in:
• calls to ergm (to estimate an ergm model) • calls to simulate (to simulate networks from an ergm model ﬁt) • calls to summary (to obtain measurements of network statistics on a dataset)
3.1 Terms provided with ergm
For a list of available terms that can be used to specify an ERGM, see Appendix B, or type: help('ergm-terms') For a more complete discussion of these terms see the ’Speciﬁcations’ paper in J Stat Software v.
24. (link is available online at www.statnet.org)

8

3.2 Coding new terms
We have recently released a new package (ergm.userterms) and tutorial aimed at making it much easier than before to write one’s own terms. The package is available on CRAN, and installing it will also download the tutorial (ergmuserterms.pdf). We teach a workshop at the Sunbelt meetings, and are also hoping for the tutorial to appear soon in the Journal of Statistical Software. Note that writing up new ergm terms requires some knowledge of C and the ability to build R from source (although the latter is covered in the tutorial).

4 Network simulation: the simulate command and network.list objects

Once we have estimated the coeﬃcients of an ERGM, the model is completely speciﬁed. It deﬁnes a probability distribution across all networks of this size. If the model is a good ﬁt to the observed data, then networks drawn from this distribution will be more likely to ”resemble” the observed data. To see examples of networks drawn from this distribution we use the simulate command:

> flomodel.03.sim <- simulate(flomodel.03,nsim=10) > class(flomodel.03.sim)
[1] "network.list"
> summary(flomodel.03.sim)
Number of Networks: 10 Model: flomarriage ~ edges + nodecov("wealth") Reference: ~Bernoulli Constraints: ~. Parameters:
edges nodecov.wealth -2.59492903 0.01054591

Stored network statistics:

edges nodecov.wealth

[1,] 24

2736

[2,] 21

2389

[3,] 20

2203

[4,] 25

2803

[5,] 26

2835

[6,] 22

2428

[7,] 21

1965

[8,] 20

2161

[9,] 21

1977

[10,] 22

2293

> length(flomodel.03.sim)

[1] 10

> flomodel.03.sim[[1]]

Network attributes: vertices = 16 directed = FALSE

9

hyper = FALSE loops = FALSE multiple = FALSE bipartite = FALSE total edges= 24
missing edges= 0 non-missing edges= 24
Vertex attribute names: priorates totalties vertex.names wealth
No edge attributes
> plot(flomodel.03.sim[[1]], label= flomodel.03.sim[[1]] %v% "vertex.names")

Acciaiuoli
Salviati Ridolfi
Pazzi

Guadagni Peruzzi

Strozzi

Pucci

Tornabuoni Barbadori

Medici

Ginori

Lamberteschi Castellani
Albizzi

Bischeri

Voila. Of course, yours will look somewhat diﬀerent.
5 Examining the quality of model ﬁt – GOF
ERGMs are generative models – that is, they represent the process that governs tie formation at a local level. These local processes in turn aggregate up to produce characteristic global network properties, even though these global properties are not explicit terms in the model. One test of whether a model ”ﬁts the data” is therefore how well it reproduces these global properties. We do this by choosing a network statistic that is not in the model, and comparing the value of this statistic observed in the original network to the distribution of values we get in simulated networks from our model.
10

> flomodel.03.gof <- gof(flomodel.03~degree) > flomodel.03.gof
Goodness-of-fit for degree

obs min mean max MC p-value

0 1 0 1.23 5

1.00

1 4 0 3.58 7

0.92

2 2 0 4.16 8

0.30

3 6 0 3.10 8

0.22

4 2 0 2.10 7

1.00

5 0 0 0.91 3

0.76

6 1 0 0.53 2

0.94

7 0 0 0.27 3

1.00

8 0 0 0.09 2

1.00

9 0 0 0.02 1

1.00

10 0 0 0.01 1

1.00

> plot(flomodel.03.gof)

Goodness−of−fit diagnostics

0.5

0.4

q

q

q

q

0.3

proportion of nodes

0.2

0.1

q q
q

q

q

q

q

q

q

q

q

q

q

q

q

q

q

q

q

q

0

1

2

3

4

5

6

7

8

9

degree

0.0

> mesamodel.02 <- ergm(mesa~edges) > mesamodel.02.gof <- gof(mesamodel.02~distance,control=control.gof.formula(nsim=10)) > plot(mesamodel.02.gof) >

11

Goodness−of−fit diagnostics
q q

0.6

0.5

0.4

proportion of dyads

0.3

0.2

q

q

q

q

q

q

q

qqqq

q

q

qqq

q q

q q

q

q

q

q

qq

q q

q
q q

q q q

qqq

qqq

qq

q

q

q

q

0.1

0.0

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
minimum geodesic distance

For a good example of model exploration and ﬁtting for the Add Health Friendship networks, see Goodreau, Kitts & Morris, Demography 2009.

6 Diagnostics: troubleshooting and checking for model degeneracy
The computational algorithms in ergm use MCMC to estimate the likelihood function. Part of this process involves simulating a set of networks to approximate unknown components of the likelihood.
When a model is not a good representation of the observed network the estimation process may be aﬀected. In the worst case scenario, the simulated networks will be so diﬀerent from the observed network that the algorithm fails altogether. This can occur for two general reasons. First, the simulation algorithm may fail to converge, and the sampled networks are thus not from the speciﬁed distribution. Second, the model parameters used to simulate the networks are too diﬀerent from the MLE, so even though the simulation algorithm is producing a representative sample of networks, this is not the sample that would be produced under the MLE.
For more detailed discussions of model degeneracy in the ERGM context, see the papers in J Stat Software v. 24. (link is available online at www.statnet.org)
We can use diagnostics to see what is happening with the simulation algorithm, and these can lead us to ways to improve it.
We will ﬁrst consider a simulation where the algorithm works. To understand the algorithm, consider
> fit <- ergm(flobusiness~edges+degree(1), + control=control.ergm(MCMC.interval=1, MCMC.burnin=1000, seed=1))
12

This runs a version with every network returned. Let us look at the diagnostics produced:
> mcmc.diagnostics(fit, center=F)
Let’s look more carefully at a default model ﬁt:
> fit <- ergm(flobusiness~edges+degree(1)) > mcmc.diagnostics(fit, center=F)
Now let us look at a more interesting case, using a larger network:
> data('faux.magnolia.high') > magnolia <- faux.magnolia.high > plot(magnolia, vertex.cex=.5)

> fit <- ergm(magnolia~edges+triangle, control=control.ergm(seed=1)) > mcmc.diagnostics(fit, center=F)

Error in ergm.MCMLE(init, nw, model, initialfit = (initialfit <- NULL), : Number of edges in a simulated network exceeds that in the observed by a factor of more than 20. Th

Very interesting. This model produced degenerate networks. You could have gotten some more feedback about this during the ﬁtting, by using:

> fit <- ergm(magnolia~edges+triangle, control=control.ergm(seed=1), verbose=T)

You might try to increase the MCMC sample size:

> fit <- ergm(magnolia~edges+triangle,seed=1, + control = control.ergm(seed=1, MCMC.samplesize=20000), + verbose=T) > mcmc.diagnostics(fit, center=F)

How about trying the more robust version of modeling triangles: GWESP? (For a technical introduction to GWESP see Hunter and Handcock; for a more intuitive description and empirical application see Goodreau Kitts and Morris 2009)

> fit <- ergm(magnolia~edges+gwesp(0.5,fixed=T), + control = control.ergm(seed=1)) > mcmc.diagnostics(fit)

Still degenerate, but maybe getting closer?

> fit <- ergm(magnolia~edges+gwesp(0.5,fixed=T)+nodematch('Grade')+nodematch('Race')+

+ nodematch('Sex'),

+ control = control.ergm(seed=1),

+ verbose=T)

> pdf('diagnostics1.pdf')

#Use the recording function if possible, otherwise send to pdf

> mcmc.diagnostics(fit)

> dev.off()

#If you saved to pdf, look at the file

> fit <- ergm(magnolia~edges+gwesp(0.25,fixed=T)+nodematch('Grade')+nodematch('Race')+

+

nodematch('Sex'),

+ control = control.ergm(seed=1))

> mcmc.diagnostics(fit)

>

13

One more try...
> fit <- ergm(magnolia~edges+gwesp(0.25,fixed=T)+nodematch('Grade')+nodematch('Race')+ + nodematch('Sex'), + control = control.ergm(seed=1,MCMC.samplesize=4096,MCMC.interval=8192), + verbose=T)

> mcmc.diagnostics(fit) Sample statistics summary:

Iterations = 131072:134340608 Thinning interval = 8192 Number of chains = 1 Sample size per chain = 16384

1. Empirical mean and standard deviation for each variable, plus standard error of the mean:

Mean SD Naive SE Time-series SE

edges

2.441 46.40 0.3625

3.689

gwesp.fixed.0.25 3.143 41.93 0.3275

4.069

nodematch.Grade 2.880 44.11 0.3446

3.810

nodematch.Race 3.618 42.73 0.3338

3.935

nodematch.Sex 1.972 37.52 0.2931

3.197

2. Quantiles for each variable:

2.5% 25% 50% 75% 97.5%

edges

-84.00 -29.00 1.00 33.00 99.00

gwesp.fixed.0.25 -72.71 -25.47 1.13 29.68 94.51

nodematch.Grade -79.00 -27.00 2.00 31.00 96.00

nodematch.Race -75.00 -26.00 1.00 31.00 93.00

nodematch.Sex -68.00 -24.00 1.00 27.00 78.00

Sample statistics cross-correlations:

edges gwesp.fixed.0.25 nodematch.Grade nodematch.Race

edges

1.0000000

0.8497712

0.9607215

0.9460052

gwesp.fixed.0.25 0.8497712

1.0000000

0.8688021

0.8483614

nodematch.Grade 0.9607215

0.8688021

1.0000000

0.9183533

nodematch.Race 0.9460052

0.8483614

0.9183533

1.0000000

nodematch.Sex 0.9050235

0.7930151

0.8739491

0.8583987

nodematch.Sex

edges

0.9050235

gwesp.fixed.0.25 0.7930151

nodematch.Grade

0.8739491

nodematch.Race

0.8583987

nodematch.Sex

1.0000000

Sample statistics auto-correlation: Chain 1

14

edges gwesp.fixed.0.25 nodematch.Grade nodematch.Race

Lag 0 1.0000000

1.0000000

1.0000000

1.0000000

Lag 8192 0.7798096

0.9818971

0.8302156

0.8175705

Lag 16384 0.7324306

0.9655592

0.7830802

0.7693207

Lag 24576 0.7050110

0.9502349

0.7577113

0.7435499

Lag 32768 0.6896580

0.9361270

0.7419942

0.7289507

Lag 40960 0.6728069

0.9227838

0.7266955

0.7141575

nodematch.Sex

Lag 0

1.0000000

Lag 8192

0.7820718

Lag 16384 0.7275206

Lag 24576 0.6979356

Lag 32768 0.6793173

Lag 40960 0.6658113

Sample statistics burn-in diagnostic (Geweke): Chain 1

Fraction in 1st window = 0.1 Fraction in 2nd window = 0.5

edges gwesp.fixed.0.25

0.4202

0.3199

nodematch.Sex

0.7801

nodematch.Grade 0.4055

nodematch.Race 0.4147

Individual P-values (lower = worse):

edges gwesp.fixed.0.25 nodematch.Grade

0.6743736

0.7490473

0.6851239

nodematch.Sex

0.4353459

Joint P-value (lower = worse): 0.5131558 .

nodematch.Race 0.6783401

MCMC diagnostics shown here are from the last round of simulation, prior to computation of final para

15

Sample statistics
edges

edges

0.000 0.004 0.008

−100 0 100

0.0e+00 5.0e+07 1.0e+08
gwesp.fixed.0.25

−200 −100

0

100 200

gwesp.fixed.0.25

0.000 0.004 0.008

−100 0 50 150

0.0e+00 5.0e+07 1.0e+08
nodematch.Grade

−100

0

100

nodematch.Grade

0.000 0.004 0.008

−100 0 100

0.0e+00 5.0e+07 1.0e+08

−100

0

100

200

Success! Of course, in real life one might have a lot more trial and error.
Changes in version 3.2 of the ergm estimation algorithm mean that the MCMC diagnostic plots can no longer be used to ensure that the mean statistics from the model match the observed network statistics. For that functionality, please use the GOF command: gof(fit, GOF=~model). The plots can still be used to assess MCMC mixing and convergence.

7 Working with egocentrically sampled network data
In many empirical contexts, it is not feasible to collect a network census or even an adaptive (linktraced) sample. Even when one of these may be possible in practice, egocentrically sampled data are typically cheaper and easier to collect.
Long regarded as the poor country cousin in the network data family, egocentric data contain a remarkable amount of information. With the right statistical methods, such data can be used to explore the properties of the complete networks in which they are embedded. The basic idea here is to combine what is observed, with assumptions, to deﬁne a class of models that describe the distribution of networks that are centered on the observed properties. The variation in these networks quantiﬁes some of the uncertainty introduced by the assumptions.
Let’s start with a simple ﬁctional example: You have a sample of persons who were asked about the friends they had seen face-to-face more than once in the last week. The respondent was asked their own sex, and the sex of each friend (for up to three friends). Summary statistics from these data thus include the sex distribution, the degree distribution (it could be broken down by sex, but we will just examine the marginal distribution here), and the joint distribution of the respondent and friend’s sex (the sex mixing matrix). Let’s assume there are equal numbers of men and women in the sampled respondents. The other distributions are shown below:
16

Degree 0 1 2 3
Total

Degree distribution

Frequency Fraction

180

0.36

245

0.49

60

0.12

15

0.03

500

1.00

Ties 0 245 120 45
410

Sex mixing matrix

(410 total)

Friend

MF

Respondent M 164 44

F 26 176

So, total N respondents = 500, total N friends reported = 410.
We can use an ERGM to ﬁt the parameters associated with these observed statistics, then use the ﬁtted model to simulate complete networks that are drawn from the distribution of networks that is centered around these statistics. As a theoretical exercise, this provides a method for investigating the complete network implications of these observed summary statistics. As an empirical exercise, the primary assumption needed for inference is that the data we have is sampled from a population in equilibrium (and, as in all statistical inference, that our model is correct). The theory for this is developed in Krivitsky, 2009.
We need to make assumptions about size, directedness and bipartite-ness when we model and simulate the complete network.

• Size: any size can be simulated, but if the model is ﬁt using the observed frequencies, it should be used to simulate a population of that size, unless a size adjustment is made in the simulation (see Krivitsky, Handcock and Morris 2011). We are going to work with a population size 500 here, equal to the number of respondents.
• Directedness: Ego data are in one sense inherently directed (respondents nominate alters, alters are not observed), but the relationship may be either. In this case (“seen more than once”) it is undirected, so we will ﬁt and simulate an undirected network.
• Bipartite: Ego data can be bipartite (if no alters are also respondents, or data are collected on 2-mode networks) or not (if respondents are also alters). But again, the relationship may be either. “Seen” is undirected, and we will ﬁt and simulated and undirected network.

In sum, we will simulate a one-mode, undirected network of size 500, assuming the ego statistics we observed contain the information we need to calculate the statistics that would have been observed in a self-contained population of that size, noting that other assumptions are possible.
To ensure consistency between the degree distribution (which is a tabulation of nodes) and the mixing matrix (which is a cross-tabulation of ties) in our simulated “complete network,” it is important to recognize that in a complete network, the degree distribution should imply twice the number of ties observed in the mixing matrix, because every tie is being reported by both nodes in the degree distribution. If we are ﬁxing the population size at 500 in this simulation, then our observed mixing matrix data needs to be divided by 2.
Start by initializing an empty network of the desired size and assign the “sex” attribute to the nodes:

> ego.net <- network.initialize(500, directed=F) > ego.net %v% 'sex' <- c(rep(0,250),rep(1,250))

Set up the observed statistics (adjusted for this “complete” network) as we will use them to assess the accuracy of the simulation later:

> ego.deg <- c(180, 245, 60, 15) > ego.mixmat <- matrix(c(164,44,26,176)/2, nrow=2, byrow=T)

# node distn # adjusted tie distn

17

Then, pick the observed statistics you want to target – we will start with a simple model here: the total number of ties (edges), and the number of sex-matched ties (homophily). These are both functions of the observed statistics:

> ego.edges <- sum(ego.mixmat) > ego.sexmatch <- ego.mixmat[1,1]+ego.mixmat[2,2]

And combine these into a vector

> ego.target.stats <- c(ego.edges, ego.sexmatch) > ego.target.stats
[1] 205 170

Now, ﬁt an ERGM to this “network”, with terms for the statistics you want to match, and the “target.stats” argument for ergm that speciﬁes the target values for those statistics:

> ego.fit <- ergm(ego.net ~ edges + nodematch('sex'), + target.stats = ego.target.stats)

Take a look at the ﬁtted model:

> summary(ego.fit)
========================== Summary of model fit ==========================

Formula: nw ~ edges + nodematch("sex") <environment: 0x55ef8ec11688>

Iterations: 8 out of 20

Monte Carlo MLE Results:

Estimate Std. Error MCMC % p-value

edges

-7.4870 0.1690

0 <1e-04 ***

nodematch.sex 1.5866 0.1857

0 <1e-04 ***

---

Signif. codes: 0 ^a˘A¨Y***^a˘A´Z 0.001 ^a˘A¨Y**^a˘A´Z 0.01 ^a˘A¨Y*^a˘A´Z 0.05 ^a˘A¨Y.^a˘A´Z 0.1 ^a˘A¨Y ^a˘A´Z 1

Null Deviance: 172940 on 124750 degrees of freedom Residual Deviance: 2941 on 124748 degrees of freedom

AIC: 2945 BIC: 2964 (Smaller is better.)

Now that you have a ﬁtted model, you can simulate a complete network from it, and look at the results:

> ego.sim1 <- simulate(ego.fit) > plot(ego.sim1, vertex.cex=.65, vertex.col="sex")

18

Does it reproduce the observed degree and mixing frequencies? We only targeted the total number of edges, not the full degree distribution.

> rbind(summary(ego.sim1 ~ degree(c(0:3))), ego.deg)

degree0 degree1 degree2 degree3

206

181

77

28

ego.deg

180

245

60

15

> mixingmatrix(ego.sim1, "sex")

Note: Marginal totals can be misleading for undirected mixing matrices. 01
0 91 42 1 42 94

> ego.mixmat

[,1] [,2] [1,] 82 22 [2,] 13 88

We only targeted the number of same-sex ties, not the full mixing matrix.
The simulation stats seem quite diﬀerent than the observed stats, and there are two possible reasons: either we mis-speciﬁed the original model (bias), or this one random draw may be unrepresentative of the distribution described by the model (variance). The latter is easily examined by simulating 100 networks, to see where the observed data fall in the distribution of networks produced by the model:

19

> ego.sim100 <- simulate(ego.fit, nsim=100) > ego.sim100

Number of Networks: 100

Model: nw ~ edges + nodematch("sex")

Reference: ~Bernoulli

Constraints: ~.

Parameters:

edges nodematch.sex

-7.487013

1.586633

More information can be obtained with
> summary(ego.sim100)
First, we’ll look at how well the simulations reproduced the target statistics that were included in the model (note, not the observed full distributions):

> sim.stats <- attr(ego.sim100,"stats") > rbind(colMeans(sim.stats), ego.target.stats)

edges nodematch.sex

205.22

169.89

ego.target.stats 205.00

170.00

These look pretty good – the means of the simulated target stats are within 1% of the observed. We can plot the 100 replicates to see check the variation for any problematic patterns:

> matplot(1:nrow(sim.stats), sim.stats, + pch=c("e","m","0","+"), cex=.65, + main="100 simulations from ego.fit model", sub="(default settings)", + xlab="Replicate", ylab="frequency") > abline(h=ego.target.stats, col=c(1:4))

20

100 simulations from ego.fit model

240

220

200

frequency

e

e

e

e

ee

e

e

e

e

ee

e

e

e

e e

ee e e

ee

e ee ee

e ee

e ee e e e

e ee

ee e

e e

ee

ee

ee

e

e

eee

ee e

e

em

e

eem

ee

e e

e

eme

e

ee e
m m ee

e ee e ee e ee

m

em

m

m

mm e m

m m

mm m

e e
e me

m

m

m m mm

m

m

mm

m

m

me

e

mmm

mm

m

mm

m

m

m

m m

mm m mmm

m m

e

m e

m m

e

m

m memmm m

m

mm mm

mm

m mm

m m

e
m emm
m m mm mm

m mm

mm m mm
m

m m
m

m
m m m

m

180

160

140

0

20

40

60

80

100

Replicate (default settings)
The lines mark the target statistic frequencies in the observed data. The points represent the frequencies in the simulated networks.
The simulated network statistics vary stochastically around the target values, not trending over time.
But, there is clear autocorrelation across the replicates, which suggests we might want to increase the MCMC interval to draw more independent realizations.

> ego.sim100 <- simulate(ego.fit, nsim=100, + control=control.simulate.ergm(MCMC.interval=10000)) > sim.stats <- attr(ego.sim100,"stats") > matplot(1:nrow(sim.stats), sim.stats, + pch=c("e","m"), cex=.65, + main="100 simulations from ego.fit model", sub="(MCMC.interval=10000)", + xlab="Replicate", ylab="frequency") > abline(h=ego.target.stats, col=c(1:2))

21

100 simulations from ego.fit model

240

220

200

frequency

e

e

e

e e

e

e

e e

e

e e

e

ee

e

e e

e

ee e

e e

e e e ee e ee

e ee

ee

e

ee e e e

e

e

ee e

ee e

e ee e

e

e e

e

ee

ee

mmmememememmmemmmememmmmmmmmmmmememmmememmmmemmemmmemmmmmemememmmemmemmmemmmmememmmmemmmmememmememmmmmeememmmmmmmemmemmememmmemememmmm m m

m

180

160

140

0

20

40

60

80

100

Replicate (MCMC.interval=10000)
With the larger interval, the autocorrelation is no longer detectable, and all of the statistics from the simulated networks vary in a symmetric band around their targets.
The variation (about +/- 10%) represents the range of target statistics that are consistent with the ﬁtted coeﬃcients.
If you wanted instead to constrain these statistics to equal a speciﬁed value, then you can use the “constraints=” argument during the ergm ﬁt instead.
This is good for verifying that the simulation reproduces the target values we speciﬁed. So now let’s see whether the simulated complete networks also match statistics that were not set by the targets. We targeted edges and homophily. How well does this model reproduce the full degree distribution?

> sim.fulldeg <- summary(ego.sim100 ~ degree(c(0:10))) > colnames(sim.fulldeg) <- paste("deg",0:10, sep='') > sim.fulldeg[1:5,]

deg0 deg1 deg2 deg3 deg4 deg5 deg6 deg7 deg8 deg9 deg10

[1,] 211 188 75 22 4 0 0 0 0 0

0

[2,] 216 184 74 24 1 0 1 0 0 0

0

[3,] 228 180 72 16 2 2 0 0 0 0

0

[4,] 245 163 66 20 4 1 1 0 0 0

0

[5,] 227 190 63 16 4 0 0 0 0 0

0

Recall that the degree range in our data was [0,3] by design, but we did not constrain the simulations to this range. If our model correctly captured the processes that led to the aggregate statistics we observe in our data, the simulated networks would show us what we missed. Here the simulated networks suggest that the fully observed network would have a wider range of degrees, which we might

22

have observed, had we not truncated the data collection at 3 friends per respondent. About 1% of nodes have degree 4 or 5, and the max observed is 6.
But did our model did correctly capture the underlying processes? How well does the simulated degree distribution from this model match the frequencies we did observe? Aggregating the degrees of 3 or more in the simulations, we ﬁnd:
> sim.deg <- cbind(sim.fulldeg[,1:3], apply(sim.fulldeg[,4:11],1,sum)) > colnames(sim.deg) <- c(colnames(sim.fulldeg)[1:3],"degree3+") > rbind(colMeans(sim.deg),ego.deg)
deg0 deg1 deg2 degree3+ 219.33 182.38 73.74 24.55 ego.deg 180.00 245.00 60.00 15.00
As with the single simulation above, the discrepancies between the simulation averages and the observed statistics are quite large. We can see this more clearly by plotting the degree frequencies for the 100 replicate networks we simulated:
> matplot(1:nrow(sim.deg), sim.deg, pch=as.character(0:3), cex=.5, + main="Comparing ego.sims to non-targeted degree frequencies", + sub = "(only total edges targeted)", + xlab = "Replicate", ylab = "Frequencies") > abline(h=c(180, 245, 60, 15), col=c(1:4))

250

Comparing ego.sims to non−targeted degree frequencies

00

0

0

0

0

0 0

0 0

0 0

00

0

0 0

00

0 0

0

0

0

0

0 0
1 1 1

0
1 11 11

0

0 01

0 1
1

0 00 01111

0

10 0

11 0

11 11

11 1 1

1

1

0 00

0

00

0 1

10 1 1
1 11 1
1

0

0

0

0

00 0 0

10 1

0

0101 1

0 11

1 11

11

1

1

0 000 0

00 0

0 01 0

0

0

0

0

0 0

0

01000000

0

0

00

0
00 0
00 1 0

1 01
1 1

1 1
111

0 11 1

1

1 1

11

1

11

1

01

1 11

1 1

11

1 11 111

1

1 11

1

1

1

1

1

1

1

200

150

Frequencies

100

2

2

2

222 222

222222222222222222

2222222222222222222222222222222222222222

2

2

2

2

2

2 22 22 2

22

22

2

2

2

2222 2

22

2

2

2

2
22 2

2

3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333

50

0

20

40

60

80

100

Replicate (only total edges targeted)
The simulations are producing systematically more isolates than expected (the “0” points vs. the black line), and systematically more degree 1 nodes. In fact, the two degree frequencies are essentially reversed in the simulation.

23

The fraction of nodes with 2 or 3+ partners is systematically oﬀ but by a much smaller amount.
So our observed network has fewer isolates than expected in a network of this density, more degree 1 nodes than expected, and fewer degree 2 and 3+ nodes.
This suggests the model is mis-speciﬁed. Since the degree 0 vs. degree 1 is the worst ﬁtting aspect, we will try using the number of isolates as a target statistic in the model.

> ego.isolates <- ego.deg[1] > ego.target.stats <- c(ego.edges, ego.sexmatch, ego.isolates) > ego.fit <- ergm(ego.net ~ edges + nodematch('sex') + degree(0), + target.stats = ego.target.stats) > summary(ego.fit)
========================== Summary of model fit ==========================

Formula: nw ~ edges + nodematch("sex") + degree(0) <environment: 0x55ef91e8fb58>

Iterations: 2 out of 20

Monte Carlo MLE Results:

Estimate Std. Error MCMC % p-value

edges

-8.3939 0.2500

0 <1e-04 ***

nodematch.sex 1.5761 0.1860

0 <1e-04 ***

degree0

-0.9602 0.1634

0 <1e-04 ***

--Signif. codes: 0 ^a˘A¨Y***^a˘A´Z 0.001 ^a˘A¨Y**^a˘A´Z 0.01 ^a˘A¨Y*^a˘A´Z 0.05 ^a˘A¨Y.^a˘A´Z 0.1 ^a˘A¨Y ^a˘A´Z 1

Null Deviance: 172940 on 124750 degrees of freedom Residual Deviance: 2903 on 124747 degrees of freedom

AIC: 2909 BIC: 2939 (Smaller is better.)

Simulating from this model, the target statistics are again well matched:

> ego.sim100 <- simulate(ego.fit, nsim=100, + control=control.simulate.ergm(MCMC.interval=10000)) > sim.stats <- attr(ego.sim100,"stats") > rbind(colMeans(sim.stats), ego.target.stats)

edges nodematch.sex degree0

204.43

169.89 180.78

ego.target.stats 205.00

170.00 180.00

And the full degree frequencies look much better:

> sim.fulldeg <- summary(ego.sim100 ~ degree(c(0:10))) > sim.deg <- cbind(sim.fulldeg[,1:3], apply(sim.fulldeg[,4:11],1,sum)) > colnames(sim.deg) <- c(colnames(sim.fulldeg)[1:3],"degree3+") > rbind(colMeans(sim.deg),ego.deg)

24

degree0 degree1 degree2 degree3+ 180.78 244.16 62.29 12.77
ego.deg 180.00 245.00 60.00 15.00
and ﬁnally, plotting the full degree frequencies
> matplot(1:nrow(sim.deg), sim.deg, pch=as.character(0:3), cex=.5, + main="Comparing ego.sims to non-targeted degree frequencies", + sub = "(only 0, 2+ and total edges targeted)", + xlab = "Replicate", ylab = "Frequencies") > abline(h=c(180, 245, 60, 15), col=c(1:4))

250

Comparing ego.sims to non−targeted degree frequencies

1

1

1

1

11 11

111

1 1

11 1

11

1 1 11
1 1 111 1
11 1

1 11 1
111 11 1

1

1

11 1

11

1

11 1

1

1 11

1

11111111111111111111111111111111111111111

1

1

0

0 00 00 000

0 00 0 0 0

00 0

0

0

0

0 00 0

00

0

0

0

0 0 000
0 0000 00

0 000 0

0

0 00

0

0

0

0

0

00

0

0 0

0

00
00 0 0

000 0

00

0

0

00 0 0

0

0

0 00

0

0

000 0

0

0 00
00 0

0

0

200

150

Frequencies

100

50

2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222 3
333333333333333333333333333333333333333333333333333333333 333333333333333333333333333333333333333333

0

0

20

40

60

80

100

Replicate (only 0, 2+ and total edges targeted)
The degree frequencies in these simulated networks are now well centered on the observed frequencies. So adding the one additional parameter to capture the lower than expected number of isolates did a good job of capturing how our observed network deviates from a random network with this density.
The fraction of nodes with 3+ partners produced by our new model might still be a bit low.
Moral: We can use ERGMs to estimate network models using target statistics from egocentrically sampled data. The fact that the target statistics are reproduced by this model does not guarantee that additional features of the network would also be reproduced. But starting with simple models can help to identify whether and how the aggregate statistics we observe from an egocentric sample deviate from those we would expect from the model. If we ﬁt all of the observed statistics without a saturated model, we cannot reject the hypothesis that this model produced the network we sampled from.
We can also use this approach to explore network statistics that are not visible at all from the egocentric data, e.g., the geodesic distribution, betweenness, etc., but it must always be remembered

25

that the distributions we will produce are based on our model. They faithfully reproduce the model, but that does not mean that the model faithfully represents the population.
In the STERGM workshop, we show how complete dynamic networks also can be simulated over time on the basis of egocentric data like these, with the minimal addition of a single estimate of partnership duration. For a movie of an example dynamic simulation used to explore the impact of network structure on HIV transmission, see statnet.org/movies.
8 Additional functionality in the statnet family of packages
8.1 In the ergm and network packages:
• ERGMs for valued ties – see the paper by Pavel Krivitsky (2012) • Analysis of bipartite networks – network recognizes this as an attribute of the network and ergm
provides speciﬁc model terms for such networks that begin with b1 or b2 (try: search.ergmTerms(categories=c(’bipartite’))).
8.2 In other packages from the statnet suite:
These are in stand-alone packages that can be downloaded either from CRAN, or from the statnet website. Many have online training materials from our workshops. For more detailed information, please visit the statnet webpage (http://statnet.org).
8.2.1 Static (cross-sectional) network analysis packages • sna – Traditional SNA methods and summaries. • latentnet – Latent space and latent cluster analysis. • netperm – Network permutation models. • degreenet – MLE estimation for degree distributions (negative binomial, Poisson, scale-free, etc.) • networksis – Simulation of bipartite networks with given degree distributions.
8.2.2 Dynamic (longitudinal) network analysis packages: • tergm – Temporal ERGMs (TERGMs): discrete-time dynamic network models for longitudinal network panel data, and other temporal extensions. • relevent – Relational event models: continuous-time dynamic network models for longitudinal network data. • networkDynamic – Dynamic network data storage and manipulation. • ndtv – Network movie maker.
26

8.3 R packages that build on statnet
There is a growing number of R packages written by other folks that build on or extend the functionality of the statnet suite. You can get a current list of those packages by looking at the reverse depends/suggests on CRAN. A partial list includes:
• EpiModel package – Mathematical Modeling of Infectious Disease, includes functions for deterministic compartmental modeling, stochastic individual contact modeling, and stochatic network modeling
• RDS package – Estimation with data collected using Respondent-Driven Sampling. • Bergm package – Bayesian ERGM estimation • hergm package – Hierarchical Exponential-Family Random Graph Models with Local Dependence
(for latent groups). • lvm4net package – Latent variable models. • VBLPCM package – Variational Bayes Latent Position Cluster Models. • xergm package – Temporal exponential random graph models (TERGM) by bootstrapped pseu-
dolikelihood, MCMC MLE and (temporal) network autocorrelation models.
8.4 Additional functionality in development:
• ergm.ego package – ERGM estimation and inference from egocentrically sampled data (expected May 2015)
• tsna package – Temporally extended (vertex and edge) SNA methods for dynamic longitudinal network data (expected May 2015)
• MLergm package – ERGM estimation and inference for multi-level data (for observed groups) (expected 2016)
9 Statnet Commons: The core development team
Mark S. Handcock <handcock@stat.ucla.edu> David R. Hunter <dhunter@stat.psu.edu> Carter T. Butts <buttsc@uci.edu> Steven M. Goodreau <goodreau@u.washington.edu> Skye Bender-deMoll <skyebend@skyeome.net> Martina Morris <morrism@u.washington.edu> Pavel N. Krivitsky <pavel@uow.edu.au>
Appendix A: Clarifying the terms – ergm and network
You will see the terms ergm and network used in multiple contexts throughout the documentation. This is common in R, but often confusing to newcomers. To clarify:
ergm
• ERGM: the acronym for an Exponential Random Graph Model; a statistical model for relational data that takes a generalized exponential family form.
27

• ergm package: one of the packages within the statnet suite • ergm function: a function within the ergm package; ﬁts an ERGM to a network object, creating
an ergm object in the process. • ergm object: a class of objects produced by a call to the ergm function, representing the results
of an ERGM ﬁt to a network. network • network: a set of actors and the relations among them. Used interchangeably with the term
graph. • network package: one of the packages within the statnet suite; used to create, store, modify
and plot the information found in network objects. • network object: a class of object in R used to represent a network.
References
Goodreau, S., J. Kitts and M. Morris (2009). Birds of a Feather, or Friend of a Friend? Using Statistical Network Analysis to Investigate Adolescent Social Networks. Demography 46(1):103-125.
Handcock, M. S., D. R. Hunter, C. T. Butts, S. M. Goodreau and M. Morris (2008). statnet: Software Tools for the Representation, Visualization, Analysis and Simulation of Network Data. Journal of Statistical Software 42(01).
Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b). ergm: A Package to Fit, Simulate and Diagnose Exponential-Family Models for Networks. Journal of Statistical Software, 24(3). http://www.jstatsoft.org/v24/i03/.
Krivitsky, P.N.(2009). PhD thesis. University of Washington, Seattle, WA Krivitsky, P. N., M. S. Handcock and M. Morris (2011). Network Size and Composition Eﬀects in
Exponential-Family Random Graph Models. Statistical Methodology 8:319-339 Krivitsky PN (2012). Exponential-family random graph models for valued networks. Electronic Journal
of Statistics 6:1100-1128
28

